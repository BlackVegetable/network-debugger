\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{epsfig,xspace,url}
\usepackage{authblk}


\title{\huge \bf DSML: an SDN-Based Debugging Tool for Distributed Systems  \\}
\author{ \Large Devin Ekins, Hadeel Maryoosh, Yue Fei, Eric Eide, Jacobus Van der Merwe}
\affil{\large School of Computing,
 University of Utah}
\date{}

\begin{document}

\maketitle

\section*{\LARGE Abstract}

( here we write the abstract)

\section*{Categories and Subject Descriptors}

( If applicable)

\section*{Keyword}

( any keyword in the paper)

\section{\LARGE Introduction}


Debugging a distributed system can be a very difficult and challenging task.  A distributed
system consists of multiple processes, running across multiple computers, that
cooperate across a network to perform some task. This debugging challenge is due to scalability of these systems which is one of their standard characteristics. An example is a web site
implemented as a distributed system including a load balancer, a set of HTTP
servers, and a set of database servers.  If the system as a whole misbehaves,
it can be tricky to figure out which of the many pieces of the system is at
fault.  Even monitoring the communication between the parts of the system can
be a challenge.

To help the users simplifying the debugging process of these systems, many proposals and tools have been presented (as discussed in section 7.) However, each of these proposals have disadvantages and drawbacks.(Elaborate here TODO.)

We present our approach, the "Debugging State Machine" (DSM), an SDN-Enhanced Debugging Tool for Distributed Systems, which is a new way to observe and control events between the components of a distributed system using Software-Defined networking (SDN) and the "Debugging State Machine Language", a domain specific programming language (DSML).  This project was motivated by the existing need for a simple, practical debugging tool that met the following characteristics: 1) It exposes only relevant traffic to the debugger, simplifying the debugging process and performing far better in the face of large amounts of network traffic.  2) Users can make use of debugging concepts analagous to those found in a traditional debugger such as a breakpoint and a stacktrace. 3) Users can specify the expected behavior of the system and capture information regarding violations to those expectations.

Using these characteristics as our goals, we built and designed our DSM approach leveraging the OpenFlow interface to meet the performance criteria, a controller capable of producing contextual information about its status similar to a stacktrace, and our DSML to allow the user to custom-tailor the debugger to their protocol's expectations.

\section{\LARGE Solution}

Our system allows users to define network protocols in terms of states of a Definite Finite Automaton (DFA) using our Debugging State Machine Language (DSML). Because explaining network protocols often involves a graphical representation as a DFA, we felt this would be a good way to model network status from the perspective of a debugger as well.

DSML supports the definition of states as well as the transitions between them. Transitions are defined by one or more matching operations which performs deep packet inspection to match a field's contents (or a substring of its contents) against a value. Alternatively, a state transition may be defined by a timeout wherein no matching packets were encountered within a given amount of time.

As deep packet expansion is expensive, we provide a mechanism to avoid inspecting the entirety of network traffic. To avoid performing these expensive operations on every packet sent through the network, DSML also supports the use of OpenFlow filters to funnel relevant traffic to the debugger itself and allow other network traffic to continue onto its original destination unimpeded. This funneling is performed at line rate. For example, a user may know that this debugger only need to consider packets with destination port of 80 for HTTP traffic. Then the debugger only performs inspection on this subset of packets.

Importantly, DSML allows for the use of side-effect operations which include logging to a file or printing to a console relevant information as well as displaying its equivalent of a stack trace. This stack trace is a history of network states that were traversed to arrive at the current position as well as the packets that were matched on for each transition. This allows users to get the feedback they need to make informed debugging decisions.

The DSML protocol script written by the user is read into a compiler to produce the Debugger State Machine (DSM) which then may be run on a controller with an OpenFlow-enabled switch to begin debugging network traffic. Switches need not support OpenFlow to send traffic to the DSM, but the optimization gained by the OpenFlow filters will not be present if OpenFlow is not supported on the switch.

\section{\LARGE Implementation}

\begin{itemize}
  \item DSML parsing
  \item DSM DPI
  \item DSML Engine (concatenation of code & compiled output)
  \item POX Controller
  \item Controller Sniffing via Scapy
  \item Connection between switch and controller
\end{itemize}

\section{\LARGE Evaluation}

\begin{itemize}
  \item Compiler performance
  \item DSML Ease of Use
  \item Run-time performance
  \item DSM Usefulness
\end{itemize}

\section{\LARGE Future Work}

\begin{itemize}
  \item Syntactic Sugar
  \item Extend Openflow (maybe?)
  \item Composition of Protocols
  \item Parallel DSMs
  \item Support for non-OF enabled switches
\end{itemize}

\section{\LARGE Related Work}

The topic of debugging distributed systems has long been studied\cite{miller1988breakpoints}, but as the scale and functionalities expected within a networked system continues to grow, the components of today's distributed system are not only deployed in a distributed fashion but are also difficult to reason about as every component within a distributed system seems to be written in a different language.\cite{chow2014mystery}. While there are good examples to debug specific distributed applications within particular domains, such as within MPI applications\cite{dryden2014pgdb}, the need for a general purpose debugging tool had not been previously met.

Using "Big Data" techniques\cite{chow2014mystery} to understand and model the behavior of a distributed system (single request triggers parallel execution of multiple software components) is a good idea since with the scale grown up, there are sufficient observations for the learning procedure. (TODO, this and the following paragraphs still need to be refined.)

There are multiple ways to observe and monitor distributed systems and the applications running on them. lprof\cite{zhao2014lprof} is statically listen to the binary code to infer how logs can be parsed and then the intertwined log entries can be associated to specific individual request. There are also low-cost hardware solution to it. Minerva\cite{sommer2013minerva} affects no execution timing and is non-intrusive. By using on-chip debug port, Minerva got full control of the system(wireless sensor network) that can stopping on one breaking point synchronously.

Other approaches including adding units either on the system or on the applications. Design a Pervasive Debugger\cite{ho2005design} for distributed applications then execute the target in a virtual environment the debugger can get control and examine the application. Declarative Tracepoints\cite{cao2008declarative} is providing a debugging system allow uses to insert action-associated checkpoints, that the applications to be debugged at runtime and require no change to source code.

Some instructive research allowed users to describe their expectations or release them from repetitious operations. Data Centric\cite{abramson2010data} allow uses to declare their expectations about the program state as a whole than a single process state, enable scalable solution to very large problems. Dataflow Language\cite{marceau2004dataflow} is programmable or scriptable for users to define the debugging work.


\section{\LARGE Conclusion}

\begin{itemize}
  \item Clearly, the internet is made for pizza.
  \item Merits of various pizza formats
  \item IEEE standard for secure pizza distribution protocol
\end{itemize}

{
  \footnotesize
  \small
  \bibliographystyle{acm}
  \bibliography{biblio}
}
\end{document}
